  /* This timeout handling is based on the blog post located at:
   *
   * blog.think-async.com/2010/04/timeouts-by-analogy.html
   *
   * The basic idea is that there are two pieces of async work in handled by a
   * serial_read_session: a read and a wait.
   *
   * The async_wait runs the handle_timout handler either when time expires or
   * when the wait operation is canceled.  Nothing will cancel the wait in this
   * program at the moment.
   *
   * The async_read reads characters from the port_ buffer into this session's
   * buffer_ container.  The async_read will exit and run read_handler when
   * either buffer_ is full or timer_ expires and invokes handle_timeout, which
   * cancels all current work operations in progress through port_.
   *
   *
   * This method of timeout is necessary only when we are using an async_read
   * operation.  The current model takes advantage of the the async_read_some
   * method to perform all reads, so these functions are removed entirely.
   *
   * If timeouts are to be re-implemented, the following should make that
   * easier.
   *
   */

  /*  Include something like this in the documentation:
   *
   *  The read and write sessions of the twnn server are separated because we have
   * a timeout implemented on reads.  We would like to rapidly create a trusted
   * communications log for our commands rather than fill our buffer each time.
   * The hope is that the integrity of the communications will be preserved by
   * this method.
   *
   * On the other hand, we would like to ensure that our whole buffer is clear
   * when we write to avoid half commands getting through to a flopoint board.
   * The boost::asio::serial_port.cancel() function cancels all read and write
   * operations in progress when it is called, so our specifications do require
   * the use of two separate boost::asio::serial_port instances: one for reading
   * and one for writing.
   *
   *
   *
   */


  /*
   * Use these to start timers in start():
          timer_.expires_from_now(boost::posix_time::milliseconds(TIMEOUT));
          timer_.async_wait(
          boost::bind(&serial_read_session::handle_timeout, this, _1));
   *
   *
   */


  /*
   * Use this to handle timeouts:
   *
  void handle_timeout(boost::system::error_code ec) {
    if (timer_.expires_from_now() < boost::posix_time::seconds(0)) {
      timer_.expires_from_now(boost::posix_time::milliseconds(TIMEOUT));
      timer_.async_wait(bind(&serial_read_session::handle_timeout, this, _1));
      port_.cancel();
      if(hurts)
        --hurts;
      else
      {
        ++count_seconds;
        hurts=1000/TIMEOUT;
      }
    } else {
      timer_.async_wait(
          boost::bind(&serial_read_session::handle_timeout, this, _1));
    }

  }
  */

  /*
   * Give the class these members:
      int count_timed_out = 0;
      boost::asio::deadline_timer timer_;
   *
   */