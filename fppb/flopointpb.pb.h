// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flopointpb.proto

#ifndef PROTOBUF_flopointpb_2eproto__INCLUDED
#define PROTOBUF_flopointpb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace flopointpb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_flopointpb_2eproto();
void protobuf_AssignDesc_flopointpb_2eproto();
void protobuf_ShutdownFile_flopointpb_2eproto();

class FloPointWaveform;
class FloPointWaveform_Waveform;
class FloPointWaveform_Jitter;
class FloPointWaveform_Time;
class FloPointWaveform_Temp;
class FloPointWaveform_Volt;
class FloPointWaveform_CompileInfo;
class FloPointWaveform_Count;

enum FloPointWaveform_TimeSource {
  FloPointWaveform_TimeSource_CLOCK0 = 0,
  FloPointWaveform_TimeSource_CLOCK1 = 1,
  FloPointWaveform_TimeSource_CLOCK2 = 2
};
bool FloPointWaveform_TimeSource_IsValid(int value);
const FloPointWaveform_TimeSource FloPointWaveform_TimeSource_TimeSource_MIN = FloPointWaveform_TimeSource_CLOCK0;
const FloPointWaveform_TimeSource FloPointWaveform_TimeSource_TimeSource_MAX = FloPointWaveform_TimeSource_CLOCK2;
const int FloPointWaveform_TimeSource_TimeSource_ARRAYSIZE = FloPointWaveform_TimeSource_TimeSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* FloPointWaveform_TimeSource_descriptor();
inline const ::std::string& FloPointWaveform_TimeSource_Name(FloPointWaveform_TimeSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    FloPointWaveform_TimeSource_descriptor(), value);
}
inline bool FloPointWaveform_TimeSource_Parse(
    const ::std::string& name, FloPointWaveform_TimeSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FloPointWaveform_TimeSource>(
    FloPointWaveform_TimeSource_descriptor(), name, value);
}
enum FloPointWaveform_TempSource {
  FloPointWaveform_TempSource_THERM0 = 0,
  FloPointWaveform_TempSource_THERM1 = 1,
  FloPointWaveform_TempSource_THERM2 = 2
};
bool FloPointWaveform_TempSource_IsValid(int value);
const FloPointWaveform_TempSource FloPointWaveform_TempSource_TempSource_MIN = FloPointWaveform_TempSource_THERM0;
const FloPointWaveform_TempSource FloPointWaveform_TempSource_TempSource_MAX = FloPointWaveform_TempSource_THERM2;
const int FloPointWaveform_TempSource_TempSource_ARRAYSIZE = FloPointWaveform_TempSource_TempSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* FloPointWaveform_TempSource_descriptor();
inline const ::std::string& FloPointWaveform_TempSource_Name(FloPointWaveform_TempSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    FloPointWaveform_TempSource_descriptor(), value);
}
inline bool FloPointWaveform_TempSource_Parse(
    const ::std::string& name, FloPointWaveform_TempSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FloPointWaveform_TempSource>(
    FloPointWaveform_TempSource_descriptor(), name, value);
}
enum FloPointWaveform_VoltSource {
  FloPointWaveform_VoltSource_VOLTM0 = 0,
  FloPointWaveform_VoltSource_VOLTM1 = 1,
  FloPointWaveform_VoltSource_VOLTM2 = 2
};
bool FloPointWaveform_VoltSource_IsValid(int value);
const FloPointWaveform_VoltSource FloPointWaveform_VoltSource_VoltSource_MIN = FloPointWaveform_VoltSource_VOLTM0;
const FloPointWaveform_VoltSource FloPointWaveform_VoltSource_VoltSource_MAX = FloPointWaveform_VoltSource_VOLTM2;
const int FloPointWaveform_VoltSource_VoltSource_ARRAYSIZE = FloPointWaveform_VoltSource_VoltSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* FloPointWaveform_VoltSource_descriptor();
inline const ::std::string& FloPointWaveform_VoltSource_Name(FloPointWaveform_VoltSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    FloPointWaveform_VoltSource_descriptor(), value);
}
inline bool FloPointWaveform_VoltSource_Parse(
    const ::std::string& name, FloPointWaveform_VoltSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FloPointWaveform_VoltSource>(
    FloPointWaveform_VoltSource_descriptor(), name, value);
}
enum FloPointWaveform_CountType {
  FloPointWaveform_CountType_MESSAGECOUNT = 0,
  FloPointWaveform_CountType_UPTIME = 1,
  FloPointWaveform_CountType_BOOTCYCLE = 2,
  FloPointWaveform_CountType_COUNT3 = 3
};
bool FloPointWaveform_CountType_IsValid(int value);
const FloPointWaveform_CountType FloPointWaveform_CountType_CountType_MIN = FloPointWaveform_CountType_MESSAGECOUNT;
const FloPointWaveform_CountType FloPointWaveform_CountType_CountType_MAX = FloPointWaveform_CountType_COUNT3;
const int FloPointWaveform_CountType_CountType_ARRAYSIZE = FloPointWaveform_CountType_CountType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FloPointWaveform_CountType_descriptor();
inline const ::std::string& FloPointWaveform_CountType_Name(FloPointWaveform_CountType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FloPointWaveform_CountType_descriptor(), value);
}
inline bool FloPointWaveform_CountType_Parse(
    const ::std::string& name, FloPointWaveform_CountType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FloPointWaveform_CountType>(
    FloPointWaveform_CountType_descriptor(), name, value);
}
// ===================================================================

class FloPointWaveform_Waveform : public ::google::protobuf::Message {
 public:
  FloPointWaveform_Waveform();
  virtual ~FloPointWaveform_Waveform();

  FloPointWaveform_Waveform(const FloPointWaveform_Waveform& from);

  inline FloPointWaveform_Waveform& operator=(const FloPointWaveform_Waveform& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloPointWaveform_Waveform& default_instance();

  void Swap(FloPointWaveform_Waveform* other);

  // implements Message ----------------------------------------------

  FloPointWaveform_Waveform* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloPointWaveform_Waveform& from);
  void MergeFrom(const FloPointWaveform_Waveform& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 wheight = 1 [packed = true];
  inline int wheight_size() const;
  inline void clear_wheight();
  static const int kWheightFieldNumber = 1;
  inline ::google::protobuf::int32 wheight(int index) const;
  inline void set_wheight(int index, ::google::protobuf::int32 value);
  inline void add_wheight(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      wheight() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_wheight();

  // @@protoc_insertion_point(class_scope:flopointpb.FloPointWaveform.Waveform)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > wheight_;
  mutable int _wheight_cached_byte_size_;
  friend void  protobuf_AddDesc_flopointpb_2eproto();
  friend void protobuf_AssignDesc_flopointpb_2eproto();
  friend void protobuf_ShutdownFile_flopointpb_2eproto();

  void InitAsDefaultInstance();
  static FloPointWaveform_Waveform* default_instance_;
};
// -------------------------------------------------------------------

class FloPointWaveform_Jitter : public ::google::protobuf::Message {
 public:
  FloPointWaveform_Jitter();
  virtual ~FloPointWaveform_Jitter();

  FloPointWaveform_Jitter(const FloPointWaveform_Jitter& from);

  inline FloPointWaveform_Jitter& operator=(const FloPointWaveform_Jitter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloPointWaveform_Jitter& default_instance();

  void Swap(FloPointWaveform_Jitter* other);

  // implements Message ----------------------------------------------

  FloPointWaveform_Jitter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloPointWaveform_Jitter& from);
  void MergeFrom(const FloPointWaveform_Jitter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 jheight = 1 [packed = true];
  inline int jheight_size() const;
  inline void clear_jheight();
  static const int kJheightFieldNumber = 1;
  inline ::google::protobuf::int32 jheight(int index) const;
  inline void set_jheight(int index, ::google::protobuf::int32 value);
  inline void add_jheight(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      jheight() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_jheight();

  // @@protoc_insertion_point(class_scope:flopointpb.FloPointWaveform.Jitter)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > jheight_;
  mutable int _jheight_cached_byte_size_;
  friend void  protobuf_AddDesc_flopointpb_2eproto();
  friend void protobuf_AssignDesc_flopointpb_2eproto();
  friend void protobuf_ShutdownFile_flopointpb_2eproto();

  void InitAsDefaultInstance();
  static FloPointWaveform_Jitter* default_instance_;
};
// -------------------------------------------------------------------

class FloPointWaveform_Time : public ::google::protobuf::Message {
 public:
  FloPointWaveform_Time();
  virtual ~FloPointWaveform_Time();

  FloPointWaveform_Time(const FloPointWaveform_Time& from);

  inline FloPointWaveform_Time& operator=(const FloPointWaveform_Time& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloPointWaveform_Time& default_instance();

  void Swap(FloPointWaveform_Time* other);

  // implements Message ----------------------------------------------

  FloPointWaveform_Time* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloPointWaveform_Time& from);
  void MergeFrom(const FloPointWaveform_Time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time_point = 1;
  inline bool has_time_point() const;
  inline void clear_time_point();
  static const int kTimePointFieldNumber = 1;
  inline ::google::protobuf::int64 time_point() const;
  inline void set_time_point(::google::protobuf::int64 value);

  // required .flopointpb.FloPointWaveform.TimeSource time_source = 2;
  inline bool has_time_source() const;
  inline void clear_time_source();
  static const int kTimeSourceFieldNumber = 2;
  inline ::flopointpb::FloPointWaveform_TimeSource time_source() const;
  inline void set_time_source(::flopointpb::FloPointWaveform_TimeSource value);

  // @@protoc_insertion_point(class_scope:flopointpb.FloPointWaveform.Time)
 private:
  inline void set_has_time_point();
  inline void clear_has_time_point();
  inline void set_has_time_source();
  inline void clear_has_time_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 time_point_;
  int time_source_;
  friend void  protobuf_AddDesc_flopointpb_2eproto();
  friend void protobuf_AssignDesc_flopointpb_2eproto();
  friend void protobuf_ShutdownFile_flopointpb_2eproto();

  void InitAsDefaultInstance();
  static FloPointWaveform_Time* default_instance_;
};
// -------------------------------------------------------------------

class FloPointWaveform_Temp : public ::google::protobuf::Message {
 public:
  FloPointWaveform_Temp();
  virtual ~FloPointWaveform_Temp();

  FloPointWaveform_Temp(const FloPointWaveform_Temp& from);

  inline FloPointWaveform_Temp& operator=(const FloPointWaveform_Temp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloPointWaveform_Temp& default_instance();

  void Swap(FloPointWaveform_Temp* other);

  // implements Message ----------------------------------------------

  FloPointWaveform_Temp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloPointWaveform_Temp& from);
  void MergeFrom(const FloPointWaveform_Temp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 temp_point = 1;
  inline bool has_temp_point() const;
  inline void clear_temp_point();
  static const int kTempPointFieldNumber = 1;
  inline ::google::protobuf::int32 temp_point() const;
  inline void set_temp_point(::google::protobuf::int32 value);

  // required .flopointpb.FloPointWaveform.TempSource temp_source = 2;
  inline bool has_temp_source() const;
  inline void clear_temp_source();
  static const int kTempSourceFieldNumber = 2;
  inline ::flopointpb::FloPointWaveform_TempSource temp_source() const;
  inline void set_temp_source(::flopointpb::FloPointWaveform_TempSource value);

  // @@protoc_insertion_point(class_scope:flopointpb.FloPointWaveform.Temp)
 private:
  inline void set_has_temp_point();
  inline void clear_has_temp_point();
  inline void set_has_temp_source();
  inline void clear_has_temp_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 temp_point_;
  int temp_source_;
  friend void  protobuf_AddDesc_flopointpb_2eproto();
  friend void protobuf_AssignDesc_flopointpb_2eproto();
  friend void protobuf_ShutdownFile_flopointpb_2eproto();

  void InitAsDefaultInstance();
  static FloPointWaveform_Temp* default_instance_;
};
// -------------------------------------------------------------------

class FloPointWaveform_Volt : public ::google::protobuf::Message {
 public:
  FloPointWaveform_Volt();
  virtual ~FloPointWaveform_Volt();

  FloPointWaveform_Volt(const FloPointWaveform_Volt& from);

  inline FloPointWaveform_Volt& operator=(const FloPointWaveform_Volt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloPointWaveform_Volt& default_instance();

  void Swap(FloPointWaveform_Volt* other);

  // implements Message ----------------------------------------------

  FloPointWaveform_Volt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloPointWaveform_Volt& from);
  void MergeFrom(const FloPointWaveform_Volt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 volt_point = 1;
  inline bool has_volt_point() const;
  inline void clear_volt_point();
  static const int kVoltPointFieldNumber = 1;
  inline ::google::protobuf::int32 volt_point() const;
  inline void set_volt_point(::google::protobuf::int32 value);

  // required .flopointpb.FloPointWaveform.VoltSource volt_source = 2;
  inline bool has_volt_source() const;
  inline void clear_volt_source();
  static const int kVoltSourceFieldNumber = 2;
  inline ::flopointpb::FloPointWaveform_VoltSource volt_source() const;
  inline void set_volt_source(::flopointpb::FloPointWaveform_VoltSource value);

  // @@protoc_insertion_point(class_scope:flopointpb.FloPointWaveform.Volt)
 private:
  inline void set_has_volt_point();
  inline void clear_has_volt_point();
  inline void set_has_volt_source();
  inline void clear_has_volt_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 volt_point_;
  int volt_source_;
  friend void  protobuf_AddDesc_flopointpb_2eproto();
  friend void protobuf_AssignDesc_flopointpb_2eproto();
  friend void protobuf_ShutdownFile_flopointpb_2eproto();

  void InitAsDefaultInstance();
  static FloPointWaveform_Volt* default_instance_;
};
// -------------------------------------------------------------------

class FloPointWaveform_CompileInfo : public ::google::protobuf::Message {
 public:
  FloPointWaveform_CompileInfo();
  virtual ~FloPointWaveform_CompileInfo();

  FloPointWaveform_CompileInfo(const FloPointWaveform_CompileInfo& from);

  inline FloPointWaveform_CompileInfo& operator=(const FloPointWaveform_CompileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloPointWaveform_CompileInfo& default_instance();

  void Swap(FloPointWaveform_CompileInfo* other);

  // implements Message ----------------------------------------------

  FloPointWaveform_CompileInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloPointWaveform_CompileInfo& from);
  void MergeFrom(const FloPointWaveform_CompileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string compiler = 1;
  inline bool has_compiler() const;
  inline void clear_compiler();
  static const int kCompilerFieldNumber = 1;
  inline const ::std::string& compiler() const;
  inline void set_compiler(const ::std::string& value);
  inline void set_compiler(const char* value);
  inline void set_compiler(const char* value, size_t size);
  inline ::std::string* mutable_compiler();
  inline ::std::string* release_compiler();
  inline void set_allocated_compiler(::std::string* compiler);

  // optional string date = 2;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 2;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // optional string operating_system = 3;
  inline bool has_operating_system() const;
  inline void clear_operating_system();
  static const int kOperatingSystemFieldNumber = 3;
  inline const ::std::string& operating_system() const;
  inline void set_operating_system(const ::std::string& value);
  inline void set_operating_system(const char* value);
  inline void set_operating_system(const char* value, size_t size);
  inline ::std::string* mutable_operating_system();
  inline ::std::string* release_operating_system();
  inline void set_allocated_operating_system(::std::string* operating_system);

  // @@protoc_insertion_point(class_scope:flopointpb.FloPointWaveform.CompileInfo)
 private:
  inline void set_has_compiler();
  inline void clear_has_compiler();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_operating_system();
  inline void clear_has_operating_system();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* compiler_;
  ::std::string* date_;
  ::std::string* operating_system_;
  friend void  protobuf_AddDesc_flopointpb_2eproto();
  friend void protobuf_AssignDesc_flopointpb_2eproto();
  friend void protobuf_ShutdownFile_flopointpb_2eproto();

  void InitAsDefaultInstance();
  static FloPointWaveform_CompileInfo* default_instance_;
};
// -------------------------------------------------------------------

class FloPointWaveform_Count : public ::google::protobuf::Message {
 public:
  FloPointWaveform_Count();
  virtual ~FloPointWaveform_Count();

  FloPointWaveform_Count(const FloPointWaveform_Count& from);

  inline FloPointWaveform_Count& operator=(const FloPointWaveform_Count& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloPointWaveform_Count& default_instance();

  void Swap(FloPointWaveform_Count* other);

  // implements Message ----------------------------------------------

  FloPointWaveform_Count* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloPointWaveform_Count& from);
  void MergeFrom(const FloPointWaveform_Count& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 count_value = 1;
  inline bool has_count_value() const;
  inline void clear_count_value();
  static const int kCountValueFieldNumber = 1;
  inline ::google::protobuf::int32 count_value() const;
  inline void set_count_value(::google::protobuf::int32 value);

  // required .flopointpb.FloPointWaveform.CountType count_type = 2;
  inline bool has_count_type() const;
  inline void clear_count_type();
  static const int kCountTypeFieldNumber = 2;
  inline ::flopointpb::FloPointWaveform_CountType count_type() const;
  inline void set_count_type(::flopointpb::FloPointWaveform_CountType value);

  // @@protoc_insertion_point(class_scope:flopointpb.FloPointWaveform.Count)
 private:
  inline void set_has_count_value();
  inline void clear_has_count_value();
  inline void set_has_count_type();
  inline void clear_has_count_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 count_value_;
  int count_type_;
  friend void  protobuf_AddDesc_flopointpb_2eproto();
  friend void protobuf_AssignDesc_flopointpb_2eproto();
  friend void protobuf_ShutdownFile_flopointpb_2eproto();

  void InitAsDefaultInstance();
  static FloPointWaveform_Count* default_instance_;
};
// -------------------------------------------------------------------

class FloPointWaveform : public ::google::protobuf::Message {
 public:
  FloPointWaveform();
  virtual ~FloPointWaveform();

  FloPointWaveform(const FloPointWaveform& from);

  inline FloPointWaveform& operator=(const FloPointWaveform& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloPointWaveform& default_instance();

  void Swap(FloPointWaveform* other);

  // implements Message ----------------------------------------------

  FloPointWaveform* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloPointWaveform& from);
  void MergeFrom(const FloPointWaveform& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FloPointWaveform_Waveform Waveform;
  typedef FloPointWaveform_Jitter Jitter;
  typedef FloPointWaveform_Time Time;
  typedef FloPointWaveform_Temp Temp;
  typedef FloPointWaveform_Volt Volt;
  typedef FloPointWaveform_CompileInfo CompileInfo;
  typedef FloPointWaveform_Count Count;

  typedef FloPointWaveform_TimeSource TimeSource;
  static const TimeSource CLOCK0 = FloPointWaveform_TimeSource_CLOCK0;
  static const TimeSource CLOCK1 = FloPointWaveform_TimeSource_CLOCK1;
  static const TimeSource CLOCK2 = FloPointWaveform_TimeSource_CLOCK2;
  static inline bool TimeSource_IsValid(int value) {
    return FloPointWaveform_TimeSource_IsValid(value);
  }
  static const TimeSource TimeSource_MIN =
    FloPointWaveform_TimeSource_TimeSource_MIN;
  static const TimeSource TimeSource_MAX =
    FloPointWaveform_TimeSource_TimeSource_MAX;
  static const int TimeSource_ARRAYSIZE =
    FloPointWaveform_TimeSource_TimeSource_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TimeSource_descriptor() {
    return FloPointWaveform_TimeSource_descriptor();
  }
  static inline const ::std::string& TimeSource_Name(TimeSource value) {
    return FloPointWaveform_TimeSource_Name(value);
  }
  static inline bool TimeSource_Parse(const ::std::string& name,
      TimeSource* value) {
    return FloPointWaveform_TimeSource_Parse(name, value);
  }

  typedef FloPointWaveform_TempSource TempSource;
  static const TempSource THERM0 = FloPointWaveform_TempSource_THERM0;
  static const TempSource THERM1 = FloPointWaveform_TempSource_THERM1;
  static const TempSource THERM2 = FloPointWaveform_TempSource_THERM2;
  static inline bool TempSource_IsValid(int value) {
    return FloPointWaveform_TempSource_IsValid(value);
  }
  static const TempSource TempSource_MIN =
    FloPointWaveform_TempSource_TempSource_MIN;
  static const TempSource TempSource_MAX =
    FloPointWaveform_TempSource_TempSource_MAX;
  static const int TempSource_ARRAYSIZE =
    FloPointWaveform_TempSource_TempSource_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TempSource_descriptor() {
    return FloPointWaveform_TempSource_descriptor();
  }
  static inline const ::std::string& TempSource_Name(TempSource value) {
    return FloPointWaveform_TempSource_Name(value);
  }
  static inline bool TempSource_Parse(const ::std::string& name,
      TempSource* value) {
    return FloPointWaveform_TempSource_Parse(name, value);
  }

  typedef FloPointWaveform_VoltSource VoltSource;
  static const VoltSource VOLTM0 = FloPointWaveform_VoltSource_VOLTM0;
  static const VoltSource VOLTM1 = FloPointWaveform_VoltSource_VOLTM1;
  static const VoltSource VOLTM2 = FloPointWaveform_VoltSource_VOLTM2;
  static inline bool VoltSource_IsValid(int value) {
    return FloPointWaveform_VoltSource_IsValid(value);
  }
  static const VoltSource VoltSource_MIN =
    FloPointWaveform_VoltSource_VoltSource_MIN;
  static const VoltSource VoltSource_MAX =
    FloPointWaveform_VoltSource_VoltSource_MAX;
  static const int VoltSource_ARRAYSIZE =
    FloPointWaveform_VoltSource_VoltSource_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VoltSource_descriptor() {
    return FloPointWaveform_VoltSource_descriptor();
  }
  static inline const ::std::string& VoltSource_Name(VoltSource value) {
    return FloPointWaveform_VoltSource_Name(value);
  }
  static inline bool VoltSource_Parse(const ::std::string& name,
      VoltSource* value) {
    return FloPointWaveform_VoltSource_Parse(name, value);
  }

  typedef FloPointWaveform_CountType CountType;
  static const CountType MESSAGECOUNT = FloPointWaveform_CountType_MESSAGECOUNT;
  static const CountType UPTIME = FloPointWaveform_CountType_UPTIME;
  static const CountType BOOTCYCLE = FloPointWaveform_CountType_BOOTCYCLE;
  static const CountType COUNT3 = FloPointWaveform_CountType_COUNT3;
  static inline bool CountType_IsValid(int value) {
    return FloPointWaveform_CountType_IsValid(value);
  }
  static const CountType CountType_MIN =
    FloPointWaveform_CountType_CountType_MIN;
  static const CountType CountType_MAX =
    FloPointWaveform_CountType_CountType_MAX;
  static const int CountType_ARRAYSIZE =
    FloPointWaveform_CountType_CountType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CountType_descriptor() {
    return FloPointWaveform_CountType_descriptor();
  }
  static inline const ::std::string& CountType_Name(CountType value) {
    return FloPointWaveform_CountType_Name(value);
  }
  static inline bool CountType_Parse(const ::std::string& name,
      CountType* value) {
    return FloPointWaveform_CountType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .flopointpb.FloPointWaveform.Waveform waveform = 2;
  inline bool has_waveform() const;
  inline void clear_waveform();
  static const int kWaveformFieldNumber = 2;
  inline const ::flopointpb::FloPointWaveform_Waveform& waveform() const;
  inline ::flopointpb::FloPointWaveform_Waveform* mutable_waveform();
  inline ::flopointpb::FloPointWaveform_Waveform* release_waveform();
  inline void set_allocated_waveform(::flopointpb::FloPointWaveform_Waveform* waveform);

  // optional .flopointpb.FloPointWaveform.Jitter jitter = 3;
  inline bool has_jitter() const;
  inline void clear_jitter();
  static const int kJitterFieldNumber = 3;
  inline const ::flopointpb::FloPointWaveform_Jitter& jitter() const;
  inline ::flopointpb::FloPointWaveform_Jitter* mutable_jitter();
  inline ::flopointpb::FloPointWaveform_Jitter* release_jitter();
  inline void set_allocated_jitter(::flopointpb::FloPointWaveform_Jitter* jitter);

  // repeated .flopointpb.FloPointWaveform.Time time_reading = 4;
  inline int time_reading_size() const;
  inline void clear_time_reading();
  static const int kTimeReadingFieldNumber = 4;
  inline const ::flopointpb::FloPointWaveform_Time& time_reading(int index) const;
  inline ::flopointpb::FloPointWaveform_Time* mutable_time_reading(int index);
  inline ::flopointpb::FloPointWaveform_Time* add_time_reading();
  inline const ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Time >&
      time_reading() const;
  inline ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Time >*
      mutable_time_reading();

  // repeated .flopointpb.FloPointWaveform.Temp temp_reading = 5;
  inline int temp_reading_size() const;
  inline void clear_temp_reading();
  static const int kTempReadingFieldNumber = 5;
  inline const ::flopointpb::FloPointWaveform_Temp& temp_reading(int index) const;
  inline ::flopointpb::FloPointWaveform_Temp* mutable_temp_reading(int index);
  inline ::flopointpb::FloPointWaveform_Temp* add_temp_reading();
  inline const ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Temp >&
      temp_reading() const;
  inline ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Temp >*
      mutable_temp_reading();

  // repeated .flopointpb.FloPointWaveform.Volt volt_reading = 6;
  inline int volt_reading_size() const;
  inline void clear_volt_reading();
  static const int kVoltReadingFieldNumber = 6;
  inline const ::flopointpb::FloPointWaveform_Volt& volt_reading(int index) const;
  inline ::flopointpb::FloPointWaveform_Volt* mutable_volt_reading(int index);
  inline ::flopointpb::FloPointWaveform_Volt* add_volt_reading();
  inline const ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Volt >&
      volt_reading() const;
  inline ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Volt >*
      mutable_volt_reading();

  // optional .flopointpb.FloPointWaveform.CompileInfo compile_info = 7;
  inline bool has_compile_info() const;
  inline void clear_compile_info();
  static const int kCompileInfoFieldNumber = 7;
  inline const ::flopointpb::FloPointWaveform_CompileInfo& compile_info() const;
  inline ::flopointpb::FloPointWaveform_CompileInfo* mutable_compile_info();
  inline ::flopointpb::FloPointWaveform_CompileInfo* release_compile_info();
  inline void set_allocated_compile_info(::flopointpb::FloPointWaveform_CompileInfo* compile_info);

  // optional int32 dipswitches = 8;
  inline bool has_dipswitches() const;
  inline void clear_dipswitches();
  static const int kDipswitchesFieldNumber = 8;
  inline ::google::protobuf::int32 dipswitches() const;
  inline void set_dipswitches(::google::protobuf::int32 value);

  // repeated .flopointpb.FloPointWaveform.Count count = 9;
  inline int count_size() const;
  inline void clear_count();
  static const int kCountFieldNumber = 9;
  inline const ::flopointpb::FloPointWaveform_Count& count(int index) const;
  inline ::flopointpb::FloPointWaveform_Count* mutable_count(int index);
  inline ::flopointpb::FloPointWaveform_Count* add_count();
  inline const ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Count >&
      count() const;
  inline ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Count >*
      mutable_count();

  // @@protoc_insertion_point(class_scope:flopointpb.FloPointWaveform)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_waveform();
  inline void clear_has_waveform();
  inline void set_has_jitter();
  inline void clear_has_jitter();
  inline void set_has_compile_info();
  inline void clear_has_compile_info();
  inline void set_has_dipswitches();
  inline void clear_has_dipswitches();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::flopointpb::FloPointWaveform_Waveform* waveform_;
  ::flopointpb::FloPointWaveform_Jitter* jitter_;
  ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Time > time_reading_;
  ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Temp > temp_reading_;
  ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Volt > volt_reading_;
  ::flopointpb::FloPointWaveform_CompileInfo* compile_info_;
  ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Count > count_;
  ::google::protobuf::int32 dipswitches_;
  friend void  protobuf_AddDesc_flopointpb_2eproto();
  friend void protobuf_AssignDesc_flopointpb_2eproto();
  friend void protobuf_ShutdownFile_flopointpb_2eproto();

  void InitAsDefaultInstance();
  static FloPointWaveform* default_instance_;
};
// ===================================================================


// ===================================================================

// FloPointWaveform_Waveform

// repeated int32 wheight = 1 [packed = true];
inline int FloPointWaveform_Waveform::wheight_size() const {
  return wheight_.size();
}
inline void FloPointWaveform_Waveform::clear_wheight() {
  wheight_.Clear();
}
inline ::google::protobuf::int32 FloPointWaveform_Waveform::wheight(int index) const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.Waveform.wheight)
  return wheight_.Get(index);
}
inline void FloPointWaveform_Waveform::set_wheight(int index, ::google::protobuf::int32 value) {
  wheight_.Set(index, value);
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.Waveform.wheight)
}
inline void FloPointWaveform_Waveform::add_wheight(::google::protobuf::int32 value) {
  wheight_.Add(value);
  // @@protoc_insertion_point(field_add:flopointpb.FloPointWaveform.Waveform.wheight)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FloPointWaveform_Waveform::wheight() const {
  // @@protoc_insertion_point(field_list:flopointpb.FloPointWaveform.Waveform.wheight)
  return wheight_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FloPointWaveform_Waveform::mutable_wheight() {
  // @@protoc_insertion_point(field_mutable_list:flopointpb.FloPointWaveform.Waveform.wheight)
  return &wheight_;
}

// -------------------------------------------------------------------

// FloPointWaveform_Jitter

// repeated int32 jheight = 1 [packed = true];
inline int FloPointWaveform_Jitter::jheight_size() const {
  return jheight_.size();
}
inline void FloPointWaveform_Jitter::clear_jheight() {
  jheight_.Clear();
}
inline ::google::protobuf::int32 FloPointWaveform_Jitter::jheight(int index) const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.Jitter.jheight)
  return jheight_.Get(index);
}
inline void FloPointWaveform_Jitter::set_jheight(int index, ::google::protobuf::int32 value) {
  jheight_.Set(index, value);
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.Jitter.jheight)
}
inline void FloPointWaveform_Jitter::add_jheight(::google::protobuf::int32 value) {
  jheight_.Add(value);
  // @@protoc_insertion_point(field_add:flopointpb.FloPointWaveform.Jitter.jheight)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FloPointWaveform_Jitter::jheight() const {
  // @@protoc_insertion_point(field_list:flopointpb.FloPointWaveform.Jitter.jheight)
  return jheight_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FloPointWaveform_Jitter::mutable_jheight() {
  // @@protoc_insertion_point(field_mutable_list:flopointpb.FloPointWaveform.Jitter.jheight)
  return &jheight_;
}

// -------------------------------------------------------------------

// FloPointWaveform_Time

// required int64 time_point = 1;
inline bool FloPointWaveform_Time::has_time_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloPointWaveform_Time::set_has_time_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloPointWaveform_Time::clear_has_time_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloPointWaveform_Time::clear_time_point() {
  time_point_ = GOOGLE_LONGLONG(0);
  clear_has_time_point();
}
inline ::google::protobuf::int64 FloPointWaveform_Time::time_point() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.Time.time_point)
  return time_point_;
}
inline void FloPointWaveform_Time::set_time_point(::google::protobuf::int64 value) {
  set_has_time_point();
  time_point_ = value;
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.Time.time_point)
}

// required .flopointpb.FloPointWaveform.TimeSource time_source = 2;
inline bool FloPointWaveform_Time::has_time_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloPointWaveform_Time::set_has_time_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FloPointWaveform_Time::clear_has_time_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FloPointWaveform_Time::clear_time_source() {
  time_source_ = 0;
  clear_has_time_source();
}
inline ::flopointpb::FloPointWaveform_TimeSource FloPointWaveform_Time::time_source() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.Time.time_source)
  return static_cast< ::flopointpb::FloPointWaveform_TimeSource >(time_source_);
}
inline void FloPointWaveform_Time::set_time_source(::flopointpb::FloPointWaveform_TimeSource value) {
  assert(::flopointpb::FloPointWaveform_TimeSource_IsValid(value));
  set_has_time_source();
  time_source_ = value;
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.Time.time_source)
}

// -------------------------------------------------------------------

// FloPointWaveform_Temp

// required int32 temp_point = 1;
inline bool FloPointWaveform_Temp::has_temp_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloPointWaveform_Temp::set_has_temp_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloPointWaveform_Temp::clear_has_temp_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloPointWaveform_Temp::clear_temp_point() {
  temp_point_ = 0;
  clear_has_temp_point();
}
inline ::google::protobuf::int32 FloPointWaveform_Temp::temp_point() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.Temp.temp_point)
  return temp_point_;
}
inline void FloPointWaveform_Temp::set_temp_point(::google::protobuf::int32 value) {
  set_has_temp_point();
  temp_point_ = value;
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.Temp.temp_point)
}

// required .flopointpb.FloPointWaveform.TempSource temp_source = 2;
inline bool FloPointWaveform_Temp::has_temp_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloPointWaveform_Temp::set_has_temp_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FloPointWaveform_Temp::clear_has_temp_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FloPointWaveform_Temp::clear_temp_source() {
  temp_source_ = 0;
  clear_has_temp_source();
}
inline ::flopointpb::FloPointWaveform_TempSource FloPointWaveform_Temp::temp_source() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.Temp.temp_source)
  return static_cast< ::flopointpb::FloPointWaveform_TempSource >(temp_source_);
}
inline void FloPointWaveform_Temp::set_temp_source(::flopointpb::FloPointWaveform_TempSource value) {
  assert(::flopointpb::FloPointWaveform_TempSource_IsValid(value));
  set_has_temp_source();
  temp_source_ = value;
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.Temp.temp_source)
}

// -------------------------------------------------------------------

// FloPointWaveform_Volt

// required int32 volt_point = 1;
inline bool FloPointWaveform_Volt::has_volt_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloPointWaveform_Volt::set_has_volt_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloPointWaveform_Volt::clear_has_volt_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloPointWaveform_Volt::clear_volt_point() {
  volt_point_ = 0;
  clear_has_volt_point();
}
inline ::google::protobuf::int32 FloPointWaveform_Volt::volt_point() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.Volt.volt_point)
  return volt_point_;
}
inline void FloPointWaveform_Volt::set_volt_point(::google::protobuf::int32 value) {
  set_has_volt_point();
  volt_point_ = value;
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.Volt.volt_point)
}

// required .flopointpb.FloPointWaveform.VoltSource volt_source = 2;
inline bool FloPointWaveform_Volt::has_volt_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloPointWaveform_Volt::set_has_volt_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FloPointWaveform_Volt::clear_has_volt_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FloPointWaveform_Volt::clear_volt_source() {
  volt_source_ = 0;
  clear_has_volt_source();
}
inline ::flopointpb::FloPointWaveform_VoltSource FloPointWaveform_Volt::volt_source() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.Volt.volt_source)
  return static_cast< ::flopointpb::FloPointWaveform_VoltSource >(volt_source_);
}
inline void FloPointWaveform_Volt::set_volt_source(::flopointpb::FloPointWaveform_VoltSource value) {
  assert(::flopointpb::FloPointWaveform_VoltSource_IsValid(value));
  set_has_volt_source();
  volt_source_ = value;
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.Volt.volt_source)
}

// -------------------------------------------------------------------

// FloPointWaveform_CompileInfo

// required string compiler = 1;
inline bool FloPointWaveform_CompileInfo::has_compiler() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloPointWaveform_CompileInfo::set_has_compiler() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloPointWaveform_CompileInfo::clear_has_compiler() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloPointWaveform_CompileInfo::clear_compiler() {
  if (compiler_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compiler_->clear();
  }
  clear_has_compiler();
}
inline const ::std::string& FloPointWaveform_CompileInfo::compiler() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.CompileInfo.compiler)
  return *compiler_;
}
inline void FloPointWaveform_CompileInfo::set_compiler(const ::std::string& value) {
  set_has_compiler();
  if (compiler_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compiler_ = new ::std::string;
  }
  compiler_->assign(value);
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.CompileInfo.compiler)
}
inline void FloPointWaveform_CompileInfo::set_compiler(const char* value) {
  set_has_compiler();
  if (compiler_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compiler_ = new ::std::string;
  }
  compiler_->assign(value);
  // @@protoc_insertion_point(field_set_char:flopointpb.FloPointWaveform.CompileInfo.compiler)
}
inline void FloPointWaveform_CompileInfo::set_compiler(const char* value, size_t size) {
  set_has_compiler();
  if (compiler_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compiler_ = new ::std::string;
  }
  compiler_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flopointpb.FloPointWaveform.CompileInfo.compiler)
}
inline ::std::string* FloPointWaveform_CompileInfo::mutable_compiler() {
  set_has_compiler();
  if (compiler_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compiler_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:flopointpb.FloPointWaveform.CompileInfo.compiler)
  return compiler_;
}
inline ::std::string* FloPointWaveform_CompileInfo::release_compiler() {
  clear_has_compiler();
  if (compiler_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = compiler_;
    compiler_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FloPointWaveform_CompileInfo::set_allocated_compiler(::std::string* compiler) {
  if (compiler_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete compiler_;
  }
  if (compiler) {
    set_has_compiler();
    compiler_ = compiler;
  } else {
    clear_has_compiler();
    compiler_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:flopointpb.FloPointWaveform.CompileInfo.compiler)
}

// optional string date = 2;
inline bool FloPointWaveform_CompileInfo::has_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloPointWaveform_CompileInfo::set_has_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FloPointWaveform_CompileInfo::clear_has_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FloPointWaveform_CompileInfo::clear_date() {
  if (date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& FloPointWaveform_CompileInfo::date() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.CompileInfo.date)
  return *date_;
}
inline void FloPointWaveform_CompileInfo::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_ = new ::std::string;
  }
  date_->assign(value);
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.CompileInfo.date)
}
inline void FloPointWaveform_CompileInfo::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_ = new ::std::string;
  }
  date_->assign(value);
  // @@protoc_insertion_point(field_set_char:flopointpb.FloPointWaveform.CompileInfo.date)
}
inline void FloPointWaveform_CompileInfo::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flopointpb.FloPointWaveform.CompileInfo.date)
}
inline ::std::string* FloPointWaveform_CompileInfo::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    date_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:flopointpb.FloPointWaveform.CompileInfo.date)
  return date_;
}
inline ::std::string* FloPointWaveform_CompileInfo::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FloPointWaveform_CompileInfo::set_allocated_date(::std::string* date) {
  if (date_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:flopointpb.FloPointWaveform.CompileInfo.date)
}

// optional string operating_system = 3;
inline bool FloPointWaveform_CompileInfo::has_operating_system() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FloPointWaveform_CompileInfo::set_has_operating_system() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FloPointWaveform_CompileInfo::clear_has_operating_system() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FloPointWaveform_CompileInfo::clear_operating_system() {
  if (operating_system_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operating_system_->clear();
  }
  clear_has_operating_system();
}
inline const ::std::string& FloPointWaveform_CompileInfo::operating_system() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.CompileInfo.operating_system)
  return *operating_system_;
}
inline void FloPointWaveform_CompileInfo::set_operating_system(const ::std::string& value) {
  set_has_operating_system();
  if (operating_system_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operating_system_ = new ::std::string;
  }
  operating_system_->assign(value);
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.CompileInfo.operating_system)
}
inline void FloPointWaveform_CompileInfo::set_operating_system(const char* value) {
  set_has_operating_system();
  if (operating_system_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operating_system_ = new ::std::string;
  }
  operating_system_->assign(value);
  // @@protoc_insertion_point(field_set_char:flopointpb.FloPointWaveform.CompileInfo.operating_system)
}
inline void FloPointWaveform_CompileInfo::set_operating_system(const char* value, size_t size) {
  set_has_operating_system();
  if (operating_system_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operating_system_ = new ::std::string;
  }
  operating_system_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flopointpb.FloPointWaveform.CompileInfo.operating_system)
}
inline ::std::string* FloPointWaveform_CompileInfo::mutable_operating_system() {
  set_has_operating_system();
  if (operating_system_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operating_system_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:flopointpb.FloPointWaveform.CompileInfo.operating_system)
  return operating_system_;
}
inline ::std::string* FloPointWaveform_CompileInfo::release_operating_system() {
  clear_has_operating_system();
  if (operating_system_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = operating_system_;
    operating_system_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FloPointWaveform_CompileInfo::set_allocated_operating_system(::std::string* operating_system) {
  if (operating_system_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operating_system_;
  }
  if (operating_system) {
    set_has_operating_system();
    operating_system_ = operating_system;
  } else {
    clear_has_operating_system();
    operating_system_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:flopointpb.FloPointWaveform.CompileInfo.operating_system)
}

// -------------------------------------------------------------------

// FloPointWaveform_Count

// required int32 count_value = 1;
inline bool FloPointWaveform_Count::has_count_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloPointWaveform_Count::set_has_count_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloPointWaveform_Count::clear_has_count_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloPointWaveform_Count::clear_count_value() {
  count_value_ = 0;
  clear_has_count_value();
}
inline ::google::protobuf::int32 FloPointWaveform_Count::count_value() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.Count.count_value)
  return count_value_;
}
inline void FloPointWaveform_Count::set_count_value(::google::protobuf::int32 value) {
  set_has_count_value();
  count_value_ = value;
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.Count.count_value)
}

// required .flopointpb.FloPointWaveform.CountType count_type = 2;
inline bool FloPointWaveform_Count::has_count_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloPointWaveform_Count::set_has_count_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FloPointWaveform_Count::clear_has_count_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FloPointWaveform_Count::clear_count_type() {
  count_type_ = 0;
  clear_has_count_type();
}
inline ::flopointpb::FloPointWaveform_CountType FloPointWaveform_Count::count_type() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.Count.count_type)
  return static_cast< ::flopointpb::FloPointWaveform_CountType >(count_type_);
}
inline void FloPointWaveform_Count::set_count_type(::flopointpb::FloPointWaveform_CountType value) {
  assert(::flopointpb::FloPointWaveform_CountType_IsValid(value));
  set_has_count_type();
  count_type_ = value;
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.Count.count_type)
}

// -------------------------------------------------------------------

// FloPointWaveform

// required string name = 1;
inline bool FloPointWaveform::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloPointWaveform::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloPointWaveform::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloPointWaveform::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FloPointWaveform::name() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.name)
  return *name_;
}
inline void FloPointWaveform::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.name)
}
inline void FloPointWaveform::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:flopointpb.FloPointWaveform.name)
}
inline void FloPointWaveform::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flopointpb.FloPointWaveform.name)
}
inline ::std::string* FloPointWaveform::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:flopointpb.FloPointWaveform.name)
  return name_;
}
inline ::std::string* FloPointWaveform::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FloPointWaveform::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:flopointpb.FloPointWaveform.name)
}

// required .flopointpb.FloPointWaveform.Waveform waveform = 2;
inline bool FloPointWaveform::has_waveform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloPointWaveform::set_has_waveform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FloPointWaveform::clear_has_waveform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FloPointWaveform::clear_waveform() {
  if (waveform_ != NULL) waveform_->::flopointpb::FloPointWaveform_Waveform::Clear();
  clear_has_waveform();
}
inline const ::flopointpb::FloPointWaveform_Waveform& FloPointWaveform::waveform() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.waveform)
  return waveform_ != NULL ? *waveform_ : *default_instance_->waveform_;
}
inline ::flopointpb::FloPointWaveform_Waveform* FloPointWaveform::mutable_waveform() {
  set_has_waveform();
  if (waveform_ == NULL) waveform_ = new ::flopointpb::FloPointWaveform_Waveform;
  // @@protoc_insertion_point(field_mutable:flopointpb.FloPointWaveform.waveform)
  return waveform_;
}
inline ::flopointpb::FloPointWaveform_Waveform* FloPointWaveform::release_waveform() {
  clear_has_waveform();
  ::flopointpb::FloPointWaveform_Waveform* temp = waveform_;
  waveform_ = NULL;
  return temp;
}
inline void FloPointWaveform::set_allocated_waveform(::flopointpb::FloPointWaveform_Waveform* waveform) {
  delete waveform_;
  waveform_ = waveform;
  if (waveform) {
    set_has_waveform();
  } else {
    clear_has_waveform();
  }
  // @@protoc_insertion_point(field_set_allocated:flopointpb.FloPointWaveform.waveform)
}

// optional .flopointpb.FloPointWaveform.Jitter jitter = 3;
inline bool FloPointWaveform::has_jitter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FloPointWaveform::set_has_jitter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FloPointWaveform::clear_has_jitter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FloPointWaveform::clear_jitter() {
  if (jitter_ != NULL) jitter_->::flopointpb::FloPointWaveform_Jitter::Clear();
  clear_has_jitter();
}
inline const ::flopointpb::FloPointWaveform_Jitter& FloPointWaveform::jitter() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.jitter)
  return jitter_ != NULL ? *jitter_ : *default_instance_->jitter_;
}
inline ::flopointpb::FloPointWaveform_Jitter* FloPointWaveform::mutable_jitter() {
  set_has_jitter();
  if (jitter_ == NULL) jitter_ = new ::flopointpb::FloPointWaveform_Jitter;
  // @@protoc_insertion_point(field_mutable:flopointpb.FloPointWaveform.jitter)
  return jitter_;
}
inline ::flopointpb::FloPointWaveform_Jitter* FloPointWaveform::release_jitter() {
  clear_has_jitter();
  ::flopointpb::FloPointWaveform_Jitter* temp = jitter_;
  jitter_ = NULL;
  return temp;
}
inline void FloPointWaveform::set_allocated_jitter(::flopointpb::FloPointWaveform_Jitter* jitter) {
  delete jitter_;
  jitter_ = jitter;
  if (jitter) {
    set_has_jitter();
  } else {
    clear_has_jitter();
  }
  // @@protoc_insertion_point(field_set_allocated:flopointpb.FloPointWaveform.jitter)
}

// repeated .flopointpb.FloPointWaveform.Time time_reading = 4;
inline int FloPointWaveform::time_reading_size() const {
  return time_reading_.size();
}
inline void FloPointWaveform::clear_time_reading() {
  time_reading_.Clear();
}
inline const ::flopointpb::FloPointWaveform_Time& FloPointWaveform::time_reading(int index) const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.time_reading)
  return time_reading_.Get(index);
}
inline ::flopointpb::FloPointWaveform_Time* FloPointWaveform::mutable_time_reading(int index) {
  // @@protoc_insertion_point(field_mutable:flopointpb.FloPointWaveform.time_reading)
  return time_reading_.Mutable(index);
}
inline ::flopointpb::FloPointWaveform_Time* FloPointWaveform::add_time_reading() {
  // @@protoc_insertion_point(field_add:flopointpb.FloPointWaveform.time_reading)
  return time_reading_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Time >&
FloPointWaveform::time_reading() const {
  // @@protoc_insertion_point(field_list:flopointpb.FloPointWaveform.time_reading)
  return time_reading_;
}
inline ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Time >*
FloPointWaveform::mutable_time_reading() {
  // @@protoc_insertion_point(field_mutable_list:flopointpb.FloPointWaveform.time_reading)
  return &time_reading_;
}

// repeated .flopointpb.FloPointWaveform.Temp temp_reading = 5;
inline int FloPointWaveform::temp_reading_size() const {
  return temp_reading_.size();
}
inline void FloPointWaveform::clear_temp_reading() {
  temp_reading_.Clear();
}
inline const ::flopointpb::FloPointWaveform_Temp& FloPointWaveform::temp_reading(int index) const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.temp_reading)
  return temp_reading_.Get(index);
}
inline ::flopointpb::FloPointWaveform_Temp* FloPointWaveform::mutable_temp_reading(int index) {
  // @@protoc_insertion_point(field_mutable:flopointpb.FloPointWaveform.temp_reading)
  return temp_reading_.Mutable(index);
}
inline ::flopointpb::FloPointWaveform_Temp* FloPointWaveform::add_temp_reading() {
  // @@protoc_insertion_point(field_add:flopointpb.FloPointWaveform.temp_reading)
  return temp_reading_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Temp >&
FloPointWaveform::temp_reading() const {
  // @@protoc_insertion_point(field_list:flopointpb.FloPointWaveform.temp_reading)
  return temp_reading_;
}
inline ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Temp >*
FloPointWaveform::mutable_temp_reading() {
  // @@protoc_insertion_point(field_mutable_list:flopointpb.FloPointWaveform.temp_reading)
  return &temp_reading_;
}

// repeated .flopointpb.FloPointWaveform.Volt volt_reading = 6;
inline int FloPointWaveform::volt_reading_size() const {
  return volt_reading_.size();
}
inline void FloPointWaveform::clear_volt_reading() {
  volt_reading_.Clear();
}
inline const ::flopointpb::FloPointWaveform_Volt& FloPointWaveform::volt_reading(int index) const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.volt_reading)
  return volt_reading_.Get(index);
}
inline ::flopointpb::FloPointWaveform_Volt* FloPointWaveform::mutable_volt_reading(int index) {
  // @@protoc_insertion_point(field_mutable:flopointpb.FloPointWaveform.volt_reading)
  return volt_reading_.Mutable(index);
}
inline ::flopointpb::FloPointWaveform_Volt* FloPointWaveform::add_volt_reading() {
  // @@protoc_insertion_point(field_add:flopointpb.FloPointWaveform.volt_reading)
  return volt_reading_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Volt >&
FloPointWaveform::volt_reading() const {
  // @@protoc_insertion_point(field_list:flopointpb.FloPointWaveform.volt_reading)
  return volt_reading_;
}
inline ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Volt >*
FloPointWaveform::mutable_volt_reading() {
  // @@protoc_insertion_point(field_mutable_list:flopointpb.FloPointWaveform.volt_reading)
  return &volt_reading_;
}

// optional .flopointpb.FloPointWaveform.CompileInfo compile_info = 7;
inline bool FloPointWaveform::has_compile_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FloPointWaveform::set_has_compile_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FloPointWaveform::clear_has_compile_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FloPointWaveform::clear_compile_info() {
  if (compile_info_ != NULL) compile_info_->::flopointpb::FloPointWaveform_CompileInfo::Clear();
  clear_has_compile_info();
}
inline const ::flopointpb::FloPointWaveform_CompileInfo& FloPointWaveform::compile_info() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.compile_info)
  return compile_info_ != NULL ? *compile_info_ : *default_instance_->compile_info_;
}
inline ::flopointpb::FloPointWaveform_CompileInfo* FloPointWaveform::mutable_compile_info() {
  set_has_compile_info();
  if (compile_info_ == NULL) compile_info_ = new ::flopointpb::FloPointWaveform_CompileInfo;
  // @@protoc_insertion_point(field_mutable:flopointpb.FloPointWaveform.compile_info)
  return compile_info_;
}
inline ::flopointpb::FloPointWaveform_CompileInfo* FloPointWaveform::release_compile_info() {
  clear_has_compile_info();
  ::flopointpb::FloPointWaveform_CompileInfo* temp = compile_info_;
  compile_info_ = NULL;
  return temp;
}
inline void FloPointWaveform::set_allocated_compile_info(::flopointpb::FloPointWaveform_CompileInfo* compile_info) {
  delete compile_info_;
  compile_info_ = compile_info;
  if (compile_info) {
    set_has_compile_info();
  } else {
    clear_has_compile_info();
  }
  // @@protoc_insertion_point(field_set_allocated:flopointpb.FloPointWaveform.compile_info)
}

// optional int32 dipswitches = 8;
inline bool FloPointWaveform::has_dipswitches() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FloPointWaveform::set_has_dipswitches() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FloPointWaveform::clear_has_dipswitches() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FloPointWaveform::clear_dipswitches() {
  dipswitches_ = 0;
  clear_has_dipswitches();
}
inline ::google::protobuf::int32 FloPointWaveform::dipswitches() const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.dipswitches)
  return dipswitches_;
}
inline void FloPointWaveform::set_dipswitches(::google::protobuf::int32 value) {
  set_has_dipswitches();
  dipswitches_ = value;
  // @@protoc_insertion_point(field_set:flopointpb.FloPointWaveform.dipswitches)
}

// repeated .flopointpb.FloPointWaveform.Count count = 9;
inline int FloPointWaveform::count_size() const {
  return count_.size();
}
inline void FloPointWaveform::clear_count() {
  count_.Clear();
}
inline const ::flopointpb::FloPointWaveform_Count& FloPointWaveform::count(int index) const {
  // @@protoc_insertion_point(field_get:flopointpb.FloPointWaveform.count)
  return count_.Get(index);
}
inline ::flopointpb::FloPointWaveform_Count* FloPointWaveform::mutable_count(int index) {
  // @@protoc_insertion_point(field_mutable:flopointpb.FloPointWaveform.count)
  return count_.Mutable(index);
}
inline ::flopointpb::FloPointWaveform_Count* FloPointWaveform::add_count() {
  // @@protoc_insertion_point(field_add:flopointpb.FloPointWaveform.count)
  return count_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Count >&
FloPointWaveform::count() const {
  // @@protoc_insertion_point(field_list:flopointpb.FloPointWaveform.count)
  return count_;
}
inline ::google::protobuf::RepeatedPtrField< ::flopointpb::FloPointWaveform_Count >*
FloPointWaveform::mutable_count() {
  // @@protoc_insertion_point(field_mutable_list:flopointpb.FloPointWaveform.count)
  return &count_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace flopointpb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::flopointpb::FloPointWaveform_TimeSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flopointpb::FloPointWaveform_TimeSource>() {
  return ::flopointpb::FloPointWaveform_TimeSource_descriptor();
}
template <> struct is_proto_enum< ::flopointpb::FloPointWaveform_TempSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flopointpb::FloPointWaveform_TempSource>() {
  return ::flopointpb::FloPointWaveform_TempSource_descriptor();
}
template <> struct is_proto_enum< ::flopointpb::FloPointWaveform_VoltSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flopointpb::FloPointWaveform_VoltSource>() {
  return ::flopointpb::FloPointWaveform_VoltSource_descriptor();
}
template <> struct is_proto_enum< ::flopointpb::FloPointWaveform_CountType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flopointpb::FloPointWaveform_CountType>() {
  return ::flopointpb::FloPointWaveform_CountType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_flopointpb_2eproto__INCLUDED
