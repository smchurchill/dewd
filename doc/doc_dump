

/*
 * README::
 *  Massive refactoring November 19th.  Any documentation dated prior to that
 *  should be considered out of date.
 *
 *
 */

/*-----------------------------------------------------------------------------
 * November 10, 2015
 * class dispatcher
 *
 * A single dispatch object should be instantiated in main, before any other
 * object is created.  Other class constructors will be overloaded to accept a
 * pointer to a dispatch object.  That dispatch object will be able to route
 * communications between our other objects.  The desired functionality is des-
 * cribed by the following example:
 *
 * 0. Server twnn is launched on pang, listening on port 50001.
 *      One dispatch object dispatch_, one server object server_, and ~enough~
 *      serial_read_session and serial_write_session objects srs_i and sws_i
 *      are instantiated.
 * 1. Client zabbix connects to pang on port 50001.
 * 2. server_ instantiates a network_session net_j to talk to zabbix.
 * 3. zabbix sends a command to pang, asking for the GUID of the flopoint board
 *      connected to serial port i.
 * 4. net_j forwards the command to dispatch which forwards the command to sws_i
 * 5. sws_i asks its board for a GUID.
 * 6. srs_i read a GUID, and sends that to dispatch.
 * 7. dispatch_ heard about a GUID from srs_i.  net_j asked for the GUID of who
 *      is attached to serial port i, so dispatch sends the GUID to net_j
 * 8. net_j forwards the GUID to zabbix.
 *
 * This level of translation is needed because the commands being issued to and
 * from the flopoint board are intended to be bjson, while the communication
 * across the network is intended to be json.  The different wrappers should be
 * simple, but necessary.
 *
 */


/*-----------------------------------------------------------------------------
 * November 18, 2015
 *
 * The initialization of the session classes in dewd.cpp requires that a class
 * has a constructor with signature:

    handler_wrapper(boost::asio::io_service& io_service,
      initializer_definer def,
      std::string logging_directory
      )

 *
 * The function that initializes all sessions also calls the public class
 * function

     void start()

 * which should cause the instance of handler_wrapper to make some work for the
 * boost::asio::io_service object passed to it.
 */


/*-----------------------------------------------------------------------------
 * November 20, 2015
 *
 * base class basic_session
 *
 * The new model for the session classes found in previous versions of dewd is
 * implemented using inheritance.  The basic_session class sets the logging
 * directory, notifies the dispatcher that it exists, and keeps track of the
 * connected io_service.
 */
 
/*-----------------------------------------------------------------------------
 * November 18, 2015
 * class serial_read_session
 * The read and write sessions of the twnn server are separated because we have
 * a timeout implemented on reads.  We would like to rapidly create a trusted
 * communications log for our commands rather than fill our buffer each time.
 * The hope is that the integrity of the communications will be preserved by
 * this method.
 *
 * On the other hand, we would like to ensure that our whole buffer is clear
 * when we write to avoid half commands getting through to a flopoint board.
 * The boost::asio::serial_port.cancel() function cancels all read and write
 * operations in progress when it is called, so our specifications do require
 * the use of two separate boost::asio::serial_port instances: one for reading
 * and one for writing.
 *
 */
 
 
  /* For now, this function begins the read/write loop with a call to
   * port_.async_read_some with handler handle_read.  It makes a new vector,
   * where the promise to free the memory is honored at the end of handle_read.
   *
   * Later, it will take care of making sure that buffer_, port_, and file_ are
   * sane.  Other specifications are tbd.
   */
   
   
  /* This handler first gives more work to the io_service.  The io_service will
   * terminate if it is ever not executing work or handlers, so passing more
   * work to the service at the start of this handler will reduce the possible
   * situations where that could happen.
   *
   * If $length > 0 then there are characters to write, and we write $length
   * characters from buffer_ to file_.  Otherwise, $length=0 and there are no
   * characters ready to write in buffer_.  We increase the count since last
   * write.  If a nonzero number of characters are written then that count is
   * set to 0.
   *
   *
   */
   
    /* The first thing we do is give more work to the io_service.  Allocate a
     * new buffer to pass to our next read operation and for our next handler
     * to read from.  That is all done in start_read().
     */
  
  
  
/*-----------------------------------------------------------------------------
 * November 18, 2015
 * class serial_write_session
 *
 * We plan to write commands to the serial port that are dictated by commands
 * read from a network socket.
 *
 * Depends:
 *  - network_session
 *  - dispatch
 */
  
  
  

/*-----------------------------------------------------------------------------
 * November 19, 2015
 * class network_socket_session
 */
  
  
  
/*-----------------------------------------------------------------------------
 * November 19, 2015
 * class network_acceptor_session
 *
 *  The following may be deprecated.
 *
 * The acceptor is initialized with a port to bind to and an io_service to ass-
 * -ign work to.  It sits on an acceptor and a socket, waiting for someone to
 * try to connect.  When a connection is accepted it is assigned to socket_,
 * and a new shared_ptr to socket_ is created and passed to a new network_sess-
 * -ion which will communicate through socket_. The server then continues to
 * sit on socket_ and acceptor_ and waits for a new connection.
 *
 * The intent is to have an acceptor listening on port 50001 over each of the
 * ip addresses on pang that are assigned to flopoint.  As of writing, those
 * are 192.168.16.X for X in [0:8].
 *
 */
  